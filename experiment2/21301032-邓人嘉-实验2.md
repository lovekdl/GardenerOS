# 操作系统实验2

> 邓人嘉 21301032

### 一、实验步骤

#### 1.1 编译生成内核镜像

* 执行cargo build --release编译
  ![image-20231103111024511](pictures/image-20231103111024511.png)
* 把编译生成的ELF执行文件转成binary文件
  ![image-20231115145344171](pictures/image-20231115145344171.png)
* 将rustsbi.bin放在bootloader目录
  ![image-20231115155515501](pictures/image-20231115155515501.png)
* 接着，加载运行生成的二进制文件。
  ![image-20231115155631560](pictures/image-20231115155631560.png)
  进入了死循环
* 分析，Entry不是0x80200000
  ![image-20231115160608753](pictures/image-20231115160608753.png)

#### 1.2 指定内存布局

* 修改os/.cargo/config 
  ![image-20231115160841004](pictures/image-20231115160841004.png)
* 创建链接文件linker.ld
  ![image-20231115161425154](pictures/image-20231115161425154.png)

#### 1.3 配置栈空间布局

* 创建汇编文件entry.asm
  ![image-20231115161516977](pictures/image-20231115161516977.png)
*  main.rs 中嵌入汇编代码并声明应用入口 rust_main
  ![image-20231115161749755](pictures/image-20231115161749755.png)

#### 1.4 清空bss段

* 为了保证内存的正确性，在main.rs中撰写代码清空.bss段
  ![image-20231115162332986](pictures/image-20231115162332986.png)

#### 1.5 实现裸机打印输出信息

* 创建文件sbi.rs
  ![image-20231115162504021](pictures/image-20231115162504021.png)
* 在os/src/console.rs中实现裸机上的print函数
  ![image-20231115162708173](pictures/image-20231115162708173.png)

#### 1.6 给异常处理增加输出信息

* 实现os/src/lang_items.rs![image-20231115162905373](pictures/image-20231115162905373.png)

#### 1.7 修改main.rs输出测试信息

* 修改main.rs的内容
  ![image-20231115163145474](pictures/image-20231115163145474.png)

#### 1.8 重新编译以及生成二进制文件

* 编译

  ![image-20231115163354329](pictures/image-20231115163354329.png)

* 生成二进制文件

  ![image-20231115163429322](pictures/image-20231115163429322.png)

* 运行

  ![image-20231115163445600](pictures/image-20231115163445600.png)

* 创建makefile文件，方便编译
  ![image-20231115163901234](pictures/image-20231115163901234.png)
  ![image-20231115164442763](pictures/image-20231115164442763.png)
  ![image-20231115164502772](pictures/image-20231115164502772.png)

### 二、思考问题

#### 2.1 分析linker.ld和entry.asm所完成的功能

* linker.ld是链接器脚本。**OUTPUT_ARCH(riscv)**指定了生成的可执行文件的体系结构为 **RISC-V**，然后指定程序入口点为**_start**，并设置**BASE_ADDRESS = 0x80200000**，因为程序入口地址约定为**0x80200000**，所以指定链接器的起始地址也设置为**0x80200000**。
  在Section部分包含了包含了代码段(**.text**)、数据段(**.data**和**.rodata**)、未初始化的数据段(**.bss**)，每一段都定义了数据在内存中的对齐格式为4KB，定义了这些段在内存中的布局。最后在**/DISCARD/**部分中舍弃了**.eh_frame**节。
* entry.asm
  **.text.entry**表示代码段入口，定义了全局符号**_start**作为程序的入口点，与链接器文件中指定的程序入口点相对应，链接器会找到此文件的**_start**入口。**_start**部分里面设置栈指针(sp)地址为启动栈栈顶地址，然后调用**rust_main**函数，转到rust代码。
  **.bss.stack**段为**boot_stack**分配了**4096*16字节**的栈空间，声明全局符号**boot_stack_top**用于获取栈顶地址。

#### 2.2 分析sbi模块和lang_items模块所完成的功能

* **sbi**模块可以更改系统调用为sbi调用。**sbi.rs**文件实现了**console_puchar**、**console_getchar**、**shutdown**三个函数，作用分别是输出一个字符、输入一个字符、关闭系统。**console_puchar**接口在**console.rs**文件中被调用，封装为输出一个字符串。**shutdown**接口在**lang_items.rs**文件中的**panic**函数被调用，用于关闭系统。
* **lang_items**实现了**panic**处理器。调用了**sbi**模块的**shutdown**接口，输出**panic**发生的错误位置以及错误信息。

#### 2.3 如果将rustsbi.bin换成最新版本的会造成代码无法运行，分析原因并给出解决方法。

* 使用最新版的rustsbi.bin，先输出了正常信息，然后进入了死循环，并且输出乱码，如下图：

  ![image-20231116194006315](pictures/image-20231116194006315.png)

  ![image-20231116194033766](pictures/image-20231116194033766.png)

  ![image-20231116194044444](pictures/image-20231116194044444.png)

* 分析原因：根据程序输出内容，可以判断是shutdown出现了问题。
  可以发现panic是这样实现的:

  ```cmd
  #[panic_handler]
  fn panic(info: &PanicInfo) -> ! {
      if let Some(location) = info.location() {
          println!(
              "Panicked at {}:{} {}",
              location.file(),
              location.line(),
              info.message().unwrap()
          );
      } else {
          println!("Panicked: {}", info.message().unwrap());
      }
      shutdown()
  }
  ```

  然后sbi的shutdown是这样实现的：

  ```cmd
  pub fn shutdown() -> ! {
      sbi_call(SBI_SHUTDOWN, 0, 0, 0);
      panic!("It should shutdown!");
  }
  
  ```

  所以可能是因为panic调用shutdown，然后shutdown里面又调用了panic，导致一直相互调用，然后死循环一直输出"It should shutdown!"。
  说明sbi_call(SBI_SHUTDOWN, 0, 0, 0)时没有成功关闭系统。

  尝试调试一下，以验证，修改shutdown：
  ![image-20231116204629566](pictures/image-20231116204629566.png)

  然后运行发现程序没有终止，进入了死循环，也没有输出，说明原因确实是：调用sbi_call(SBI_SHUTDOWN, 0, 0, 0)时没有成功关闭系统。

  查看sbi_call函数：

  ![image-20231116205458746](pictures/image-20231116205458746.png)考虑到新版rustsbi可能不是这样调用接口的。发现文档中说一些SBI函数被遗弃了，其中包含了EID为0x08的shutdown。

  ![image-20231116213301954](pictures/image-20231116213301954.png)

  于是参照下图的replacement EID把shutdown的EID修改为0x53525354(实际上是sbi_system_reset 的EID)。但其它被遗弃的函数的EID使用原来的并没有影响，所以不用改变，只需要改变shutdown的EID为sbi_system_reset的EID 0x53525354就好。（并且需要添加FID）<img src="pictures/image-20231116213458137.png" alt="image-20231116213458137" style="zoom:50%;" />
  修改后的sbi.rs如下：

  ![image-20231116214044359](pictures/image-20231116214044359.png)

  然后运行成功，最后系统成功关闭：
  ![image-20231116214404335](pictures/image-20231116214404335.png)

### 三、git截图

* git截图
  ![image-20231116215010300](pictures/image-20231116215010300.png)![image-20231116215021016](pictures/image-20231116215021016.png)![image-20231116215124407](pictures/image-20231116215124407.png)

